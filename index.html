--- START OF FILE index.html ---

<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>桌上模型公仔神生成系統</title>
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">

    <!-- Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <!-- Custom CSS -->
    <style>
        /* --- Constants for Icon Sizes --- */
        :root {
            --icon-size-standard: 1.5rem; /* 24px */
            --icon-size-large: 2rem;     /* 32px */
        }
        
        /* --- BRIGHT, MINIMALIST, STREAMLINED THEME COLOR PALETTE & BASE STYLES --- */
        :root {
            --bg-light-primary: #FFFFFF; /* Pure white for main background */
            --bg-panel-light: #F8FAFC;   /* Very light gray for main panels, subtle contrast */
            --bg-sub-panel-light: #F0F4F8; /* Even lighter gray for sub-panels */
            
            --text-dark-primary: #2C3E50; /* Dark blue-gray for main text */
            --text-muted-light: #7F8C8D; /* Muted gray for secondary text */

            --accent-blue-main: #3498DB; /* Vibrant blue for primary actions/highlights */
            --accent-blue-light: #5DADE2; /* Lighter blue for hover */
            --accent-green-vibrant: #2ECC71; /* Vibrant green for success/CTA */
            --accent-green-light: #58D68D; /* Lighter green for hover */
            --accent-purple-soft: #A78BFA; /* Soft purple for secondary highlights/glows (retained for mascot/particles) */

            --border-soft: #E0E6ED;     /* Very light gray for borders */
            --border-highlight: #C2D9ED; /* Slightly darker for subtle highlights */
            
            --shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.08); /* Very soft, light shadow */
            --shadow-subtle: 0 2px 6px rgba(0, 0, 0, 0.05);
            --shadow-inset-light: inset 0 1px 3px rgba(0, 0, 0, 0.05);

            --error-light: #E74C3C; /* Clean red for errors */

            --font-display: 'Inter', sans-serif; 
            --font-body: 'Inter', sans-serif;
        }
        
        body { 
            font-family: var(--font-body); 
            background-color: var(--bg-light-primary); 
            color: var(--text-dark-primary); 
            line-height: 1.6;
            overflow-x: hidden; 
        }

        /* Font Awesome specific sizing to match conceptual sizes */
        .fa-icon-standard { font-size: var(--icon-size-standard); } /* 1.5rem (24px) */
        .fa-icon-large { font-size: var(--icon-size-large); }     /* 2rem (32px) */
        .fa-icon-medium { font-size: 1.25rem; } /* For w-5 h-5 (20px) */
        .fa-icon-small { font-size: 1rem; }    /* For w-4 h-4 (16px) */
        .fa-icon-xl { font-size: 2.5rem; }     /* For larger placeholder icon */
        .fa-icon-xxl { font-size: 3.5rem; }    /* For even larger placeholder icon */


        /* Grid pattern for profile picture previews, with a cleaner look */
        .bg-grid-pattern {
            background-color: var(--bg-sub-panel-light);
            background-image: linear-gradient(var(--border-soft) 1px, transparent 1px), 
                              linear-gradient(90deg, var(--border-soft) 1px, transparent 1px); 
            background-size: 25px 25px; 
            box-shadow: var(--shadow-inset-light); /* Inner subtle shadow */
            border: 1px solid var(--border-soft); 
        }
        
        /* Animations */
        @keyframes fade-in-down {
            0% { opacity: 0; transform: translateY(-30px) translateX(-50%); }
            100% { opacity: 1; transform: translateY(0) translateX(-50%); }
        }
        .animate-fade-in-down { animation: fade-in-down 0.5s cubic-bezier(.25,.8,.25,1) forwards; }
        
        /* --- API Key Section Styles --- */
        .info-box {
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 10px;
            border-left: 4px solid;
            font-size: 0.9rem;
            background-color: rgba(52, 152, 219, 0.08); /* Light blue background */
            border-color: var(--accent-blue-main);
            color: var(--text-dark-primary); 
        }
        .info-box ul {
            padding-left: 1.5rem; /* Added padding to lists */
        }
        .api-key-label-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .api-key-label-wrapper label {
            font-size: 0.95rem; font-weight: 500; color: var(--text-dark-primary); flex-grow: 1;
        }
        .api-tutorial-link { color: var(--accent-blue-main); cursor: pointer; text-decoration: underline dotted; font-size: 0.9rem; }

        /* --- Mascot Styles --- */
        #mascot {
            position: fixed;
            bottom: 30px; 
            left: 30px;
            width: clamp(110px, 16vw, 160px); 
            z-index: 998;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(.36,.07,.19,.97);
            /* Keeping original glow colors for contrast and 'magic' feel */
            filter: drop-shadow(0 0 10px var(--accent-blue-main)) drop-shadow(0 0 20px var(--accent-purple-soft)); 
        }
        #mascot:hover {
            transform: scale(1.15); 
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
            filter: drop-shadow(0 0 15px var(--accent-blue-main)) drop-shadow(0 0 30px var(--accent-purple-soft)); 
        }
        @keyframes shake {
            10%, 90% { transform: scale(1.15) translate3d(-1px, 0, 0); }
            20%, 80% { transform: scale(1.15) translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: scale(1.15) translate3d(-3px, 0, 0); }
            40%, 60% { transform: scale(1.15) translate3d(3px, 0, 0); }
        }
        .particle {
            position: fixed;
            pointer-events: none;
            border-radius: 50%;
            opacity: 0;
            z-index: 1001;
        }

        /* --- Global Component Adjustments --- */
        .container { 
            max-width: 1500px; 
            margin: 0 auto; 
            padding: 50px 30px 100px; 
        }
        header { text-align: center; margin-bottom: 70px; }
        header h1 { 
            font-family: var(--font-display); 
            font-size: 5.5rem; 
            font-weight: 900; 
            color: var(--text-dark-primary); /* Dark title on light background */
            letter-spacing: -0.06em; 
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.05); /* Soft, subtle shadow */
        }
        header p { 
            font-family: var(--font-body);
            font-size: 1.5rem; 
            color: var(--text-muted-light); 
            margin-top: 15px; 
            letter-spacing: 0.03em;
        }

        /* Initial Setup Grid for API Key and Image Upload */
        .initial-setup-grid {
            display: grid;
            grid-template-columns: 1fr; /* Default to single column on small screens */
            gap: 40px;
            margin-bottom: 50px; 
        }
        @media (min-width: 1024px) { /* Tailwind 'lg' breakpoint */
            .initial-setup-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        /* Main Console Panel */
        .console-panel {
            background-color: var(--bg-panel-light);
            backdrop-filter: blur(5px); /* Lighter blur */
            border-radius: 30px; 
            padding: 45px;
            box-shadow: var(--shadow-soft);
            border: 1px solid var(--border-soft); 
            margin-bottom: 90px;
            display: flex;
            flex-direction: column; 
            gap: 40px; 
            position: relative;
        }
        /* Console border glow animation - made subtle */
        .console-panel::before {
            content: '';
            position: absolute;
            top: 0px; left: 0px; right: 0px; bottom: 0px; 
            background: linear-gradient(45deg, var(--accent-blue-main), var(--accent-green-vibrant), var(--accent-blue-main));
            background-size: 200% 200%; /* Reduced for performance */
            border-radius: 30px;
            z-index: -1;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.5s ease-in-out;
            animation: borderGlow 6s ease infinite; /* Reduced duration */
        }
        .console-panel:hover::before {
            opacity: 0.08; /* Very subtle glow on hover */
        }
        @keyframes borderGlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }


        .console-section-header { 
            font-family: var(--font-display);
            font-size: 2.2rem; 
            font-weight: 700; 
            color: var(--text-dark-primary); 
            margin-bottom: 30px; 
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-soft); 
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.03); /* Very subtle */
            letter-spacing: 0.04em;
            display: flex; 
            align-items: center; 
            gap: 12px; 
        }
        /* Style for icons in console-section-header */
        .console-section-header .fa-solid {
            color: var(--accent-blue-main); 
        }
        
        /* Unified Sub-Panel Styling */
        .console-sub-panel {
            background-color: var(--bg-sub-panel-light);
            border-radius: 20px; 
            padding: 30px;
            border: 1px solid var(--border-soft);
            box-shadow: var(--shadow-subtle);
        }
        .console-sub-panel h3, .console-sub-panel h4 { 
            color: var(--text-dark-primary); 
            font-weight: 600;
            margin-bottom: 20px;
            font-size: 1.6rem; 
            text-shadow: none;
            display: flex; 
            align-items: center; 
            gap: 10px; 
        }
         /* Style for icons in console-sub-panel h3 */
        .console-sub-panel h3 .fa-solid {
            color: var(--accent-blue-main); 
        }
        .console-sub-panel .info-text { 
            color: var(--text-muted-light);
            font-size: 0.95rem;
            margin-bottom: 20px;
        }

        /* Image Upload Area */
        .image-upload-area {
            height: 380px; 
            border: 3px dashed var(--border-soft); 
            background-color: var(--bg-light-primary);
            border-radius: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease-out;
            overflow: hidden;
            position: relative;
        }
        .image-upload-area.drag-over {
            border-color: var(--accent-blue-main); 
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.2);
            background-color: rgba(52, 152, 219, 0.05);
        }

        .image-upload-area:hover:not(.has-image) { 
            border-color: var(--accent-blue-light); 
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.1); 
        }
        .image-upload-area img { object-fit: cover; } 
        .upload-placeholder { color: var(--text-muted-light); }
        .upload-placeholder .fa-solid { font-size: 3.5rem; margin-bottom: 20px; color: var(--accent-blue-main); }
        .upload-buttons { margin-top: 25px; display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; } 


        /* Inputs and Textareas */
        input[type="password"], textarea, select, input[type="number"] {
            width: 100%; 
            padding: 14px 18px; 
            border-radius: 10px; 
            border: 1px solid var(--border-soft);
            background-color: var(--bg-light-primary); 
            color: var(--text-dark-primary); 
            font-size: 1rem;
            transition: all 0.3s ease-out;
            box-shadow: var(--shadow-inset-light);
            -webkit-appearance: none; 
            -moz-appearance: none;
            appearance: none;
        }
        select {
            background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="none" stroke="%237F8C8D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>'); 
            background-repeat: no-repeat;
            background-position: right 1em top 50%; 
            background-size: 0.9em auto;
        }

        input[type="password"]:focus, textarea:focus, select:focus, input[type="number"]:focus { 
            outline: none; 
            border-color: var(--accent-blue-main); 
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2), var(--shadow-inset-light); 
        }
        textarea { resize: vertical; min-height: 90px; }


        /* Button Styling Overrides */
        .button {
            padding: 14px 30px; 
            border-radius: 12px; 
            font-weight: 600; 
            letter-spacing: 0.08em; 
            text-transform: uppercase;
            transition: all 0.3s cubic-bezier(.25,.8,.25,1);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            z-index: 1;
            box-shadow: var(--shadow-subtle);
        }
        .button::before { /* Subtle accent border effect */
            content: '';
            position: absolute;
            top: 0px; left: 0px; right: 0px; bottom: 0px; 
            background: linear-gradient(45deg, var(--accent-blue-main), var(--accent-green-vibrant), var(--accent-blue-main));
            background-size: 200% 200%; /* Reduced for performance */
            border-radius: 12px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        .button:hover::before {
            opacity: 0.1; /* Very subtle effect */
            animation: buttonGlow 2.5s linear infinite;
        }
        @keyframes buttonGlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .button-primary {
            background: var(--accent-green-vibrant);
            color: var(--bg-light-primary);
            border: 1px solid var(--accent-green-vibrant);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        .button-primary:hover:not(:disabled) {
            background: var(--accent-green-light); 
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 15px rgba(46, 204, 113, 0.3);
        }
        .button-secondary {
            background: var(--bg-light-primary);
            color: var(--accent-blue-main);
            border: 1px solid var(--border-highlight);
            box-shadow: var(--shadow-subtle);
        }
        .button-secondary:hover:not(:disabled) {
            background: var(--accent-blue-main);
            color: var(--bg-light-primary);
            border-color: var(--accent-blue-main);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 15px rgba(52, 152, 219, 0.3);
        }
        /* Explicitly change Font Awesome icon color on hover for secondary button */
        .button-secondary:hover:not(:disabled) .fa-solid {
            color: var(--bg-light-primary); 
        }
        .button:disabled {
            background: var(--bg-sub-panel-light);
            border-color: var(--border-soft);
            color: var(--text-muted-light);
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
            box-shadow: none;
        }
        .button-icon-only {
            padding: 12px; 
            width: 50px; 
            height: 50px;
            border-radius: 50%;
        }
        .button-icon-only .fa-solid { font-size: 1.25rem; } /* fa-icon-medium */

        /* --- Global Generate Button --- */
        .generate-button-area {
            text-align: center;
            margin-top: 50px; 
            margin-bottom: 90px; 
        }
        .generate-button-area .button {
            width: 70%; 
            max-width: 450px;
            padding: 18px 0; 
            font-size: 1.6rem;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4); 
        }
        .generate-button-area .button:hover:not(:disabled) {
            box-shadow: 0 8px 25px rgba(46, 204, 113, 0.6), 0 0 10px rgba(52, 152, 219, 0.1); 
        }


        /* --- Results Panel --- */
        .results-section { margin-top: 100px; text-align: center; }
        .results-section .console-section-header { color: var(--text-dark-primary); }
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); 
            gap: 30px; 
            margin-top: 50px;
        }
        .results-loader-progress {
            background-color: var(--bg-sub-panel-light);
            border-radius: 50px; 
            height: 10px; 
            overflow: hidden;
            box-shadow: var(--shadow-inset-light);
            border: 1px solid var(--border-soft);
        }
        .results-loader-bar {
            background: linear-gradient(90deg, var(--accent-blue-main), var(--accent-green-vibrant)); 
            height: 100%;
            border-radius: 50px;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.3), 0 0 15px rgba(46, 204, 113, 0.2); 
        }


        /* Profile Picture Display Cards */
        .profile-card-base { 
            padding: 25px; 
            background-color: var(--bg-sub-panel-light);
            border-radius: 20px;
            box-shadow: var(--shadow-subtle);
            border: 1px solid var(--border-soft);
            transition: all 0.3s cubic-bezier(.25,.8,.25,1);
            position: relative;
            overflow: hidden;
        }
        .profile-card-base:hover {
            transform: translateY(-8px) scale(1.04); 
            box-shadow: var(--shadow-soft);
            border-color: var(--accent-blue-main);
        }
        .profile-card-image-wrapper { 
            aspect-ratio: 1 / 1;
            background-color: var(--bg-light-primary); 
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-soft);
        }
        .profile-card-image-wrapper img { width: 100%; height: 100%; object-fit: cover; } 
        .profile-card-pose-name { 
            text-align: center; 
            margin-top: 20px; 
            font-size: 1.2rem; 
            font-weight: 600; 
            color: var(--text-dark-primary); 
            text-shadow: none;
        }
        .profile-actions { 
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .profile-card-base:hover .profile-actions { opacity: 1; }
        .profile-actions button {
            background-color: rgba(255, 255, 255, 0.7); 
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-soft);
            color: var(--text-dark-primary);
            padding: 10px; 
            border-radius: 50%;
            transition: all 0.2s ease-out;
            box-shadow: var(--shadow-subtle);
        }
        .profile-actions button:hover {
            background-color: var(--accent-blue-main);
            color: var(--bg-light-primary);
            border-color: var(--accent-blue-main);
            transform: scale(1.1);
        }

        /* Tooltip Styles */
        .tooltip {
            position: relative;
        }
        .tooltip .tooltip-text {
            visibility: hidden;
            width: max-content;
            background-color: var(--text-dark-primary);
            color: var(--bg-light-primary);
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
        }
        .tooltip .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--text-dark-primary) transparent transparent transparent;
        }
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }


        /* Loader and Error Cards */
        @keyframes mascot-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .loading-card-mascot {
            animation: mascot-spin 1.2s linear infinite;
            width: 70%; 
            height: 70%;
            object-fit: contain;
            /* Keep original mascot glow colors for 'magic' feel */
            filter: drop-shadow(0 0 6px var(--accent-blue-main)) drop-shadow(0 0 12px var(--accent-purple-soft));
        }

        .error-card-border {
            border-color: var(--error-light);
        }
        .error-card-text {
            color: var(--error-light);
        }

        /* Custom upload loading animation */
        @keyframes upload-glow {
            0% { box-shadow: 0 0 6px var(--accent-blue-main), var(--shadow-inset-light); }
            50% { box-shadow: 0 0 15px rgba(52, 152, 219, 0.2), inset 0 0 10px rgba(52, 152, 219, 0.1); }
            100% { box-shadow: 0 0 6px var(--accent-blue-main), var(--shadow-inset-light); }
        }
        .uploading-animation {
            animation: upload-glow 1.8s infinite ease-in-out;
        }

        /* Footer */
        footer { 
            text-align: center; 
            padding: 40px 0; 
            font-size: 0.9rem; 
            color: var(--text-muted-light); 
            margin-top: 100px;
        }

        /* Modals */
        .modal-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; 
            align-items: center; z-index: 1000; animation: fadeIn 0.3s;
        }
        .modal-content { 
            background: var(--bg-panel-light); padding: 40px; border-radius: 25px; 
            max-width: 800px; width: 90%; position: relative; box-shadow: var(--shadow-soft); 
            max-height: 90vh; overflow-y: auto; border: 1px solid var(--border-highlight);
            backdrop-filter: blur(8px);
        }
        .modal-content h3 { color: var(--accent-blue-main); margin-bottom: 25px; font-size: 2rem; }
        .modal-content p, .modal-content li { color: var(--text-dark-primary); margin-bottom: 12px; }
        .modal-content a { color: var(--accent-blue-main); text-decoration: none; }
        .modal-content a:hover { text-decoration: underline; }
        .modal-close { 
            position: absolute; top: 20px; right: 20px; font-size: 2.8rem; 
            color: var(--text-muted-light); cursor: pointer; transition: transform 0.2s; 
        }
        .modal-close:hover { transform: scale(1.15); color: var(--accent-blue-main); }


        /* Responsive Adjustments */
        @media (max-width: 1279px) { /* Tablets */
            header h1 { font-size: 4rem; }
            header p { font-size: 1.1rem; }
            .initial-setup-grid { margin-bottom: 40px; }
            .console-panel { padding: 35px; gap: 35px; border-radius: 25px; }
            .console-section-header { font-size: 1.8rem; margin-bottom: 20px; padding-bottom: 12px; gap: 10px;}
            .console-sub-panel { padding: 25px; border-radius: 18px; } 
            .console-sub-panel h3, .console-sub-panel h4 { font-size: 1.4rem; margin-bottom: 18px; gap: 8px;}
            .console-sub-panel .info-text { font-size: 0.9rem; margin-bottom: 18px;}
            .image-upload-area { height: 320px; border-width: 2px; border-radius: 15px; }
            .upload-buttons { gap: 12px; margin-top: 20px; }
            .button { padding: 12px 22px; gap: 10px; font-size: 0.95rem; border-radius: 10px; border-width: 1px; }
            .generate-button-area .button { font-size: 1.4rem; padding: 16px 0; }
            .results-grid { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 20px; }
            .profile-card-base { padding: 20px; border-radius: 15px; }
            .profile-card-pose-name { font-size: 1rem; margin-top: 15px; }
            .profile-actions { top: 12px; right: 12px; gap: 8px; }
            .profile-actions button { padding: 9px; }
            #mascot { width: clamp(90px, 14vw, 130px); bottom: 20px; left: 20px; }
            .modal-content { padding: 35px; border-radius: 20px; }
            .modal-content h3 { font-size: 1.8rem; margin-bottom: 20px; }
            .modal-close { font-size: 2.2rem; top: 15px; right: 15px; }
            footer { margin-top: 90px; padding: 35px 0; font-size: 0.85rem; }
        }

        @media (max-width: 767px) { /* Mobile */
            header h1 { font-size: 3rem; letter-spacing: -0.04em; }
            header p { font-size: 0.9rem; margin-top: 10px; }
            .container { padding: 20px 15px 50px; }
            .initial-setup-grid { margin-bottom: 30px; }
            .console-panel { padding: 20px; gap: 25px; margin-bottom: 50px; border-radius: 20px;}
            .console-section-header { font-size: 1.5rem; margin-bottom: 15px; padding-bottom: 8px; gap: 8px; }
            .console-sub-panel { padding: 15px; border-radius: 15px; } 
            .console-sub-panel h3, .console-sub-panel h4 { font-size: 1.2rem; margin-bottom: 12px; gap: 6px;}
            .console-sub-panel .info-text { font-size: 0.8rem; margin-bottom: 12px;}
            .image-upload-area { height: 250px; border-width: 2px; border-radius: 12px; }
            .upload-placeholder .fa-solid { font-size: 3rem; margin-bottom: 15px; }
            .upload-buttons { flex-direction: column; gap: 10px; margin-top: 15px; }
            .button { padding: 10px 18px; font-size: 0.85rem; gap: 8px; border-radius: 8px; border-width: 1px; }
            input[type="password"], textarea, select, input[type="number"] { padding: 10px 12px; font-size: 0.85rem; border-radius: 8px;}
            .generate-button-area .button { font-size: 1.2rem; padding: 14px 0; border-radius: 10px; }
            .results-section { margin-top: 70px; }
            .results-grid { gap: 12px; margin-top: 30px; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));}
            .profile-card-base { padding: 15px; border-radius: 12px; }
            .profile-card-pose-name { font-size: 0.9rem; margin-top: 12px; }
            .profile-actions { top: 10px; right: 10px; gap: 6px; }
            .profile-actions button { padding: 7px; }
            .modal-content { padding: 25px; border-radius: 15px; }
            .modal-content h3 { font-size: 1.5rem; margin-bottom: 15px; }
            .modal-close { font-size: 2rem; top: 10px; right: 10px; }
            footer { margin-top: 70px; padding: 30px 0; font-size: 0.75rem; }
            #mascot { width: clamp(70px, 16vw, 100px); bottom: 15px; left: 15px; }
        }

        /* Custom Loading Spinner CSS */
        @keyframes spin-circle {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-spinner {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 3px solid var(--border-soft); /* Light gray base for the circle */
            border-top-color: var(--accent-blue-main); /* First color of the arc */
            border-right-color: var(--accent-green-vibrant); /* Second color of the arc */
            animation: spin-circle 0.8s linear infinite;
        }

    </style>

    <!-- React CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- JSZip CDN (for downloading all images as zip) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

</head>
<body class="bg-light-primary text-dark-primary">
    <div id="root"></div>

    <!-- Mascot element -->
    <img id="mascot" src="image/LiyuChillGuy.svg" alt="吉祥物 LiyuChillGuy">
    
    <script>
        // --- Mascot and Particle Effects Logic (Optimized) ---
        const mascotElement = document.getElementById('mascot');
        const audioManager = { 
            ctx: null,
            init: function() {
                try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } 
                catch (e) { console.error("Web Audio API is not supported."); this.ctx = null; }
            },
            _playSoundNode: function(type, frequency, duration, volume, rampTargetFreq) {
                if (!this.ctx) return;
                const oscillator = this.ctx.createOscillator();
                const gainNode = this.ctx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.ctx.destination);
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, this.ctx.currentTime);
                if (rampTargetFreq) oscillator.frequency.linearRampToValueAtTime(rampTargetFreq, this.ctx.currentTime + duration * 0.8);
                gainNode.gain.setValueAtTime(volume, this.ctx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.00001, this.ctx.currentTime + duration);
                oscillator.start(this.ctx.currentTime);
                oscillator.stop(this.ctx.currentTime + duration);
            },
            play: async function(soundName) {
                if (!this.ctx) return;
                if (this.ctx.state === 'suspended') { try { await this.ctx.resume(); } catch (e) { console.error("Failed to resume AudioContext:", e); return; } }
                if (soundName === 'sparkle') {
                    this._playSoundNode('triangle', 1500, 0.08, 0.1, 2500); 
                    setTimeout(() => this._playSoundNode('sine', 1800, 0.08, 0.06), 60);
                }
            }
        };
        audioManager.init();

        function createParticles(x, y) {
            const particleCount = 10; 
            const colors = ['var(--accent-blue-main)', 'var(--accent-blue-light)', 'var(--accent-purple-soft)', 'var(--accent-green-vibrant)']; 
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                document.body.appendChild(particle);
                const size = Math.random() * 8 + 4; 
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 60 + 40; 
                const endX = Math.cos(angle) * distance;
                const endY = Math.sin(angle) * distance;
                particle.style.left = `${x - size / 2}px`;
                particle.style.top = `${y - size / 2}px`;
                const animation = particle.animate(
                    [{ transform: 'translate(0, 0) scale(1)', opacity: 1 }, { transform: `translate(${endX}px, ${endY}px) scale(0)`, opacity: 0 }],
                    { duration: Math.random() * 600 + 400, easing: 'cubic-bezier(0.1, 0.9, 0.2, 1)', fill: 'forwards' } 
                );
                animation.onfinish = () => particle.remove();
            }
        }

        if (mascotElement) {
            mascotElement.addEventListener('click', (e) => {
                audioManager.play('sparkle');
                const rect = mascotElement.getBoundingClientRect();
                createParticles(rect.left + rect.width / 2, rect.top + rect.height / 2);
            });
        }
    </script>

    <script type="text/babel">
        // Destructure React hooks for convenience
        const { useState, useRef, useEffect, useCallback, useMemo } = React;

        // --- Constants ---
        const CONSTANTS = {
            API_URLS: {
                GENERATE_IMAGE: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent',
            },
            MAX_RETRIES: 5,
            INITIAL_BACKOFF: 1000,
            FIXED_GENERATE_COUNT: 1, 
            DEBOUNCE_DELAY: 300,
            GENERATION_DELAY: 500, // Small delay between image generations for visual effect
            RATE_LIMIT_COOLDOWN_SECONDS: 60, // New constant for cooldown after 429
            MAX_IMAGE_SIZE_MB: 8, // Increased max size for detailed character images
            MAX_IMAGE_DIMENSIONS: { width: 4096, height: 4096 }, // Increased max dimensions
            LOGO_IMAGE_PATH: 'logo/LiyuChillGuy.png', 
                        SYSTEM_INSTRUCTION: {
                parts: [{
                    text: "You are an image generation AI. Your sole purpose is to create an image based on the user's text prompt and uploaded image. Do not respond with any text, greetings, or explanations. Only output the final image."
                }]
            },
            // Generation config as used in Puti-AI example, REMOVED responseMimeType
            GENERATION_CONFIG: {
                responseModalities: ['IMAGE'] // Explicitly only request IMAGE
            }
        };

        // --- Figure Generation Prompts (for different scene/style variations) ---
        // The base prompt remains the same, but we will generate 3 variations of it.
        // Updated prompt to include the LiyuChillGuy LOGO
        const FIGURE_BASE_PROMPT = `指令：生成一張圖片。風格：超寫實商品攝影。內容：一個 1/7 比例的模型公仔，角色基於上傳的圖片。場景：公仔在現代電腦桌上，底座是透明圓形壓克力。旁邊的電腦螢幕顯示該模型的 ZBrush 3D 線框圖。螢幕旁有 BANDAI 風格的玩具包裝盒，盒面印有角色插畫，包裝盒上帶有上傳的 LiyuChillGuy LOGO 圖片作為品牌標誌。光線明亮，細節豐富。`; 


        // --- Utility Functions ---

        /**
         * Converts a File object to a Base64 data URL.
         * @param {File} file - The file to convert.
         * @returns {Promise<string>} A promise that resolves with the Base64 data URL.
         */
        const toBase64 = file => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
        });

        /**
         * Converts a Blob object to a Base64 data URL.
         * @param {Blob} blob - The blob to convert.
         * @returns {Promise<string>} A promise that resolves with the Base64 data URL.
         */
        const blobToBase64 = blob => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });

        /**
         * Debounces a function call.
         * @param {Function} func - The function to debounce.
         * @param {number} wait - The debounce delay in milliseconds.
         * @returns {Function} The debounced function.
         */
        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), wait);
            };
        };

        /**
         * Sanitizes an API key by removing non-alphanumeric characters (except hyphen and underscore) and trimming whitespace.
         * @param {string} key - The API key to sanitize.
         * @returns {string} The sanitized API key.
         */
        const sanitizeApiKey = (key) => key.replace(/[^a-zA-Z0-9-_]/g, '').trim();

        /**
         * Sets an application-wide error message and logs it.
         * @param {Function} setError - React state setter for the error.
         * @param {string} message - The error message.
         * @param {string} [consoleMessage=message] - Message to log to console.
         */
        const setAppError = (setError, message, consoleMessage = message) => {
            console.error(consoleMessage);
            setError(message);
        };

        /**
         * Fetches data with retry logic for transient errors (e.g., 429 Too Many Requests).
         * @param {string} url - The URL to fetch.
         * @param {Object} options - Fetch API options.
         * @param {number} [retries=CONSTANTS.MAX_RETRIES] - Number of retries.
         * @param {number} [backoff=CONSTANTS.INITIAL_BACKOFF] - Initial backoff delay in milliseconds.
         * @returns {Promise<Object>} A promise that resolves with the JSON response, or throws an error.
         */
        const fetchWithRetry = async (url, options, retries = CONSTANTS.MAX_RETRIES, backoff = CONSTANTS.INITIAL_BACKOFF) => {
            let lastError;
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    const errorData = await response.json().catch(() => ({})); // Always try to parse JSON for errors

                    if (!response.ok) {
                        console.error('API 錯誤回應:', response.status, errorData);

                        if (response.status === 429 && i < retries - 1) { // Retry for rate limits
                            console.log(`請求頻率過高 (429)。將在 ${backoff / 1000} 秒後重試...`);
                            await new Promise(res => setTimeout(res, backoff));
                            backoff *= 2; // Exponential backoff
                            continue;
                        } else if (response.status === 401) {
                            throw new Error(`API 請求失敗，狀態碼 401：未授權。請確認您的 API 金鑰是否有效。`);
                        } else if (response.status === 429) { // Last 429 attempt failed
                             throw new Error(`API 請求頻率過高，或配額已用盡 (429)。請稍後再試，或檢查您的 Google AI Studio 配額。`);
                        }
                        else {
                            throw new Error(`API 請求失敗，狀態碼 ${response.status}: ${errorData.error?.message || '未知錯誤'}`);
                        }
                    }
                    return errorData; // Return parsed JSON on success
                } catch (error) {
                    lastError = error;
                    console.error(`第 ${i + 1}/${retries} 次嘗試失敗:`, error);
                    if (i < retries - 1 && !(error.message.includes('401') || error.message.includes('配額'))) { // Don't retry for 401 or definite quota issues
                        console.log(`等待 ${backoff / 1000} 秒後進行下一次嘗試...`);
                        await new Promise(res => setTimeout(res, backoff));
                        backoff *= 2;
                    } else if (error.message.includes('429') && i === retries -1) {
                        // If the last retry failed due to 429, rethrow with specific message
                        throw new Error(`API 請求頻率過高，或配額已用盡。請稍後再試，或檢查您的 Google AI Studio 配額。`);
                    }
                }
            }
            throw lastError; // Rethrow the last encountered error after all attempts fail
        };

        /**
         * Generates an image using the Gemini API with retry logic.
         * @param {Object} payload - The request payload for the image generation API.
         * @param {Function} getActiveApiKey - A function to get the current active API key.
         * @param {number} [totalAttempts=3] - The maximum number of attempts for the image generation.
         * @returns {Promise<string>} A promise that resolves with the Base64 data URL of the generated image.
         */
        const generateImageWithRetry = async (payload, getActiveApiKey, totalAttempts = 3) => {
            let lastError;
            const apiKey = getActiveApiKey();
            if (!apiKey) {
                throw new Error("請輸入有效的 Google Gemini API 金鑰以生成模型公仔。請檢查設定中的金鑰是否正確。");
            }

            for (let attempt = 1; attempt <= totalAttempts; attempt++) {
                try {
                    const apiUrl = `${CONSTANTS.API_URLS.GENERATE_IMAGE}?key=${apiKey}`;
                    
                    const result = await fetchWithRetry(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    const candidate = result?.candidates?.[0];

                    if (!candidate) {
                        console.error("API 完整回應 (缺少 candidate):", result); // Log full response for debugging
                        throw new Error('API 回應格式無效，缺少候選項目。');
                    }

                    // --- Puti-AI 範例的關鍵檢查點 ---
                    // 1. 檢查完成原因 (finishReason)
                    if (candidate.finishReason && candidate.finishReason !== 'STOP') {
                        console.error("API 完成原因非 STOP:", candidate.finishReason, result); // Log full response for debugging
                        throw new Error(`圖片生成因 '${candidate.finishReason}' 而停止。這可能是因為內容不適當、長度限制或其他內部原因。`);
                    }

                    // 2. 檢查安全評級 (safetyRatings)
                    if (candidate.safetyRatings?.some(rating => rating.probability !== 'NEGLIGIBLE' && rating.category !== 'HARM_CATEGORY_UNSPECIFIED')) {
                        const blockedCategories = candidate.safetyRatings
                            .filter(rating => rating.probability !== 'NEGLIGIBLE' && rating.category !== 'HARM_CATEGORY_UNSPECIFIED')
                            .map(rating => rating.category)
                            .join(', ');
                        console.error("API 安全評級偵測到問題:", candidate.safetyRatings, result); // Log full response for debugging
                        throw new Error(`請求因安全考量被拒絕。偵測到類別：${blockedCategories}。請嘗試使用不同的角色圖片或提示詞。`);
                    }
                    // --- 結束 Puti-AI 範例的關鍵檢查點 ---
                    
                    const base64Data = candidate?.content?.parts?.[0]?.inlineData?.data;

                    if (base64Data) {
                        return `data:image/png;base64,${base64Data}`;
                    } else {
                        // 如果沒有圖片，檢查是否有文字回應，這可能包含錯誤訊息
                        const textPart = candidate?.content?.parts?.find(p => p.text);
                        if (textPart && textPart.text.trim()) {
                            console.error("API 未回傳圖片但有文字訊息:", textPart.text, result); // Log full response for debugging
                            throw new Error(`API 未回傳圖片，但提供了以下訊息：「${textPart.text}」`);
                        } else {
                            console.error("API 回應中未找到有效的圖片或文字資料:", result); // Log full response for debugging
                            throw new Error('API 回應中未找到有效的圖片或文字資料。請檢查開發人員控制台以獲取完整回應。');
                        }
                    }

                } catch (error) {
                    lastError = error;
                    console.error(`第 ${attempt}/${totalAttempts} 次圖片生成嘗試失敗:`, error);
                }

                if (attempt < totalAttempts) {
                    const delay = 2500 * Math.pow(2, attempt - 1); // Exponential backoff for attempts
                    console.log(`等待 ${delay / 1000} 秒後進行下一次圖片生成嘗試...`);
                    await new Promise(res => setTimeout(res, delay));
                }
            }

            throw lastError; // Rethrow the last encountered error after all attempts fail
        };

        /**
         * Generates the model instruction for a figure.
         * @param {string} promptText - The selected figure prompt text.
         * @returns {string} The detailed instruction string for the AI model.
         */
        const getModelInstruction = (promptText) => { 
            return `The highest priority is to perfectly replicate the character's design, facial features, hair, clothing, and overall identity from the provided reference photo into a 3D model. Do not alter their age, gender, or core design elements.
            ${promptText}`;
        };

        // --- Shared React Components ---

        /**
         * Renders a loading spinner.
         * @param {Object} props - Component props.
         * @param {string} [props.size='fa-icon-standard'] - CSS class for spinner size.
         * @param {string} [props.className=''] - Additional CSS classes.
         */
        const LoadingSpinner = ({ size = 'fa-icon-standard', className = '' }) => {
            return (
                <div className={`loading-spinner ${size} ${className}`} role="status" aria-label="Loading">
                    <span className="sr-only">Loading...</span>
                </div>
            );
        };

        /**
         * Renders a modal close button.
         * @param {Object} props - Component props.
         * @param {Function} props.onClick - Function to call on click.
         * @param {boolean} [props.disabled=false] - Whether the button is disabled.
         */
        const ModalCloseButton = ({ onClick, disabled }) => (
            <button onClick={onClick} disabled={disabled} className="modal-close" aria-label="關閉模態視窗">
                <i className="fa-solid fa-xmark fa-2xl"></i>
            </button>
        );

        /**
         * Renders a tooltip.
         * @param {Object} props - Component props.
         * @param {React.Node} props.children - The element to which the tooltip is attached.
         * @param {string} props.text - The tooltip text.
         */
        const Tooltip = ({ children, text }) => (
            <div className="tooltip relative group">
                {children}
                <span className="tooltip-text absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 hidden group-hover:block bg-text-dark-primary text-bg-light-primary text-xs rounded py-1 px-2 whitespace-nowrap z-10">
                    {text}
                </span>
                {/* CSS for tooltip arrow is already in global styles. No need for ::after in JSX */}
            </div>
        );

        /**
         * Renders a styled button.
         * @param {Object} props - Component props.
         * @param {React.Node} props.children - Button content.
         * @param {Function} props.onClick - Click handler.
         * @param {boolean} [props.disabled=false] - Whether the button is disabled.
         * @param {boolean} [props.primary=false] - If true, renders a primary button.
         * @param {string} [props.className=''] - Additional CSS classes.
         * @param {string} props.ariaLabel - Accessible label for the button.
         */
        const Button = ({ children, onClick, disabled, primary = false, className = '', ariaLabel }) => {
            const baseClass = "button"; 
            const themeClass = primary 
                ? "button-primary" 
                : "button-secondary"; 
            
            return (
                <button
                    onClick={onClick}
                    disabled={disabled}
                    className={`${baseClass} ${themeClass} ${className}`}
                    aria-label={ariaLabel}
                    aria-disabled={disabled || undefined}
                >
                    {children}
                </button>
            );
        };

        /**
         * Displays a generated figure with download/regenerate options.
         * @param {Object} props - Component props.
         * @param {string} props.sceneName - Name of the figure scene type (e.g., "現代電腦桌公仔 #1").
         * @param {string} props.imageUrl - URL of the image.
         * @param {Function} props.onDownload - Handler for downloading the image.
         * @param {Function} props.onRegenerate - Handler for regenerating the image.
         * @param {'success'|'failed'} props.status - Status of the image generation.
         */
        const FigureDisplayCard = ({ sceneName, imageUrl, onDownload, onRegenerate, status }) => {
            let statusIcon;
            let cardClass = "profile-card-base"; // Reusing style but with figure context
            if (status === 'success') {
                statusIcon = <i className="fa-solid fa-circle-check fa-icon-standard text-accent-green-vibrant"></i>;
            } else if (status === 'failed') {
                statusIcon = <i className="fa-solid fa-circle-xmark fa-icon-standard text-error-light"></i>;
                cardClass += " border-error-light/50";
            }

            return (
                <div className={`relative group ${cardClass}`}>
                    <div className="profile-card-image-wrapper">
                        <img src={imageUrl} alt={`您的模型公仔 - ${sceneName}`} className="w-full h-full object-cover" />
                    </div>
                    <p className="profile-card-pose-name">{sceneName}</p>
                    
                    <div className="profile-actions">
                        {status === 'success' && (
                            <>
                                <Tooltip text="重新生成此款模型公仔">
                                    <button
                                        onClick={onRegenerate}
                                        aria-label={`重新生成 "${sceneName}" 模型公仔`}
                                    >
                                        <i className="fa-solid fa-arrow-rotate-right fa-icon-medium"></i>
                                    </button>
                                </Tooltip>
                                <Tooltip text="下載模型公仔圖片">
                                    <button
                                        onClick={() => onDownload(imageUrl, sceneName)}
                                        aria-label={`下載 "${sceneName}" 模型公仔圖片`}
                                    >
                                        <i className="fa-solid fa-download fa-icon-medium"></i>
                                    </button>
                                </Tooltip>
                            </>
                        )}
                        {status === 'failed' && (
                            <Tooltip text="重試生成">
                                <button
                                    onClick={onRegenerate}
                                    aria-label={`重試生成 "${sceneName}" 模型公仔`}
                                    className="bg-error-light hover:bg-error-light/80"
                                >
                                    <i className="fa-solid fa-arrow-rotate-right fa-icon-medium text-white"></i>
                                </button>
                            </Tooltip>
                        )}
                    </div>
                    <div className="absolute top-3 left-3 z-10">
                        {statusIcon}
                    </div>
                </div>
            );
        };

        /**
         * Renders a skeleton loader.
         * @param {Object} props - Component props.
         * @param {string} [props.className='h-5 w-1/2'] - CSS classes for size and shape.
         */
        const SkeletonLoader = ({ className = "h-5 w-1/2" }) => (
            <div className={`animate-pulse bg-border-soft rounded-md ${className}`}></div>
        );

        /**
         * Renders a loading state figure card.
         * @param {Object} props - Component props.
         * @param {string} props.sceneName - Name of the figure scene type being loaded.
         * @param {'pending'|'generating'} props.status - Current loading status.
         */
        const LoadingFigureCard = ({ sceneName, status }) => {
            return (
                <div className="profile-card-base">
                    <div className="profile-card-image-wrapper">
                        <LoadingSpinner className="fa-icon-large" />
                    </div>
                    <div className="mt-3 flex justify-center">
                        <SkeletonLoader />
                    </div>
                    <p className="text-center text-sm text-text-muted-light">{status === 'generating' ? '生成中...' : '準備中...'}</p>
                </div>
            );
        };

        /**
         * Renders an error state figure card with a retry option.
         * @param {Object} props - Component props.
         * @param {string} props.sceneName - Name of the figure scene type that failed.
         * @param {Function} props.onRegenerate - Handler for retrying generation.
         */
        const ErrorFigureCard = ({ sceneName, onRegenerate }) => {
            return (
                <div className="profile-card-base border-error-light/50">
                    <div className="profile-card-image-wrapper flex flex-col items-center justify-center p-4 border-2 border-dashed error-card-border">
                        <p className="font-medium mb-4 error-card-text">生成失敗</p>
                        <Button onClick={onRegenerate} primary ariaLabel={`重試生成 "${sceneName}" 模型公仔`}>
                            <i className="fa-solid fa-arrow-rotate-right fa-icon-medium"></i>
                            重試
                        </Button>
                    </div>
                    <p className="profile-card-pose-name">{sceneName}</p>
                    <div className="absolute top-3 left-3 z-10">
                        <i className="fa-solid fa-circle-xmark fa-icon-standard text-error-light"></i>
                    </div>
                </div>
            );
        };

        /**
         * Displays a transient error notification at the top of the screen.
         * @param {Object} props - Component props.
         * @param {string|null} props.message - The error message to display.
         * @param {Function} props.onDismiss - Function to call when the notification is dismissed.
         */
        const ErrorNotification = ({ message, onDismiss }) => {
            if (!message) return null;
            return (
                <div className="fixed top-5 left-1/2 z-50 w-full max-w-md p-4 bg-panel-light border border-border-highlight text-dark-primary rounded-lg shadow-soft flex items-center justify-between animate-fade-in-down" style={{ transform: 'translateX(-50%)' }}>
                    <span>{message}</span>
                    <button onClick={onDismiss} className="p-1 rounded-full hover:bg-bg-sub-panel-light transition-colors ml-4" aria-label="關閉錯誤通知">
                        <i className="fa-solid fa-xmark fa-icon-medium text-text-muted-light"></i>
                    </button>
                </div>
            );
        };
        
        /**
         * Modal providing instructions on how to obtain a Google Gemini API key.
         * @param {Object} props - Component props.
         * @param {boolean} props.isOpen - Whether the modal is open.
         * @param {Function} props.onClose - Handler to close the modal.
         */
        const ApiKeyTutorialModal = ({ isOpen, onClose }) => {
            if (!isOpen) return null;
            return (
                <div className="modal-overlay">
                    <div className="modal-content">
                        <h3 className="flex items-center gap-2">
                            <i className="fa-solid fa-gear fa-icon-large"></i>
                            如何取得免費的 Google Gemini API 金鑰？
                        </h3>
                        <p>按照以下簡單步驟，即可取得您自己的免費金鑰，享受更穩定、個人化的服務。</p>
                        <ol className="list-decimal list-inside text-left mb-4">
                            <li className="mb-2">前往 <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer">Google AI Studio 的 API 金鑰頁面</a>。</li>
                            <li className="mb-2">使用您的 Google 帳號登入。</li>
                            <li className="mb-2">點擊頁面上的 <strong>「建立 API 金鑰」(Create API key)</strong> 按鈕。</li>
                            <li className="mb-2">系統會立即產生一組新的金鑰。點擊金鑰旁邊的複製圖示。</li>
                            <li>回到本頁面，將複製的金鑰貼到輸入框中即可！</li>
                        </ol>
                        <p className="text-sm text-error-light mb-2"><strong>提醒：</strong></p>
                        <ul className="list-disc list-inside text-sm text-error-light mb-4">
                            <li>請妥善保管您的 API 金鑰，不要與他人分享。</li>
                            <li>免費金鑰有使用配額限制。若頻繁遇到 "請求頻率過高 (429)" 或 "配額用盡" 錯誤，請前往 <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="text-accent-blue-main underline">Google AI Studio</a> 查看您的配額使用情況。</li>
                        </ul>

                        <ModalCloseButton onClick={onClose} ariaLabel="關閉 API 金鑰教學模態視窗" />
                    </div>
                </div>
            );
        };

        /**
         * Handles API key input and display, including the tutorial modal.
         * @param {Object} props - Component props.
         * @param {string} props.apiKey - Current API key value.
         * @param {Function} props.onApiKeyChange - Callback for API key changes.
         * @param {boolean} props.isAnyAiProcessActive - Flag to disable input during AI processes.
         */
        const ApiKeyInputSection = ({ apiKey, onApiKeyChange, isAnyAiProcessActive }) => {
            const [isApiKeyModalOpen, setIsApiKeyModalOpen] = useState(false);

            return (
                <div className="console-panel">
                    <h2 className="console-section-header">
                        <i className="fa-solid fa-gear fa-icon-large text-accent-blue-main"></i>
                        前置設定：API 金鑰
                    </h2>
                    <div className="info-box">
                        <p>為使用 AI 模型公仔生成功能，請先前往 Google AI Studio 申請並貼上您的免費 API 金鑰。此金鑰將僅儲存在您的瀏覽器中，不會上傳至任何伺服器。</p>
                    </div>
                    <div className="mt-4">
                        <div className="api-key-label-wrapper">
                            <label htmlFor="user-api-key">您的 Google Gemini API 金鑰 (必填)</label>
                            <span className="api-tutorial-link" onClick={() => setIsApiKeyModalOpen(true)}>(如何取得？)</span>
                        </div>
                        <input
                            type="password"
                            id="user-api-key"
                            placeholder="請貼上您從 Google AI Studio 取得的 API 金鑰"
                            value={apiKey}
                            onChange={(e) => onApiKeyChange(e.target.value)}
                            autoComplete="off"
                            disabled={isAnyAiProcessActive}
                            aria-label="Google Gemini API 金鑰輸入框"
                        />
                    </div>
                    <ApiKeyTutorialModal 
                        isOpen={isApiKeyModalOpen} 
                        onClose={() => setIsApiKeyModalOpen(false)} 
                    />
                </div>
            );
        };

        /**
         * Handles image upload (via file input or drag-drop).
         * @param {Object} props - Component props.
         * @param {string|null} props.uploadedImage - Base64 URL of the current uploaded image.
         * @param {Function} props.onImageSelected - Callback when an image is selected.
         * @param {Function} props.setAppError - Function to set application-wide errors.
         * @param {boolean} props.isAnyAiProcessActive - Flag to disable actions during AI processes.
         */
        const ImageUploadSection = ({ uploadedImage, onImageSelected, setAppError, isAnyAiProcessActive }) => {
            const fileInputRef = useRef(null);
            const [isUploading, setIsUploading] = useState(false);

            const handleImageFile = useCallback(async (file) => {
                if (!file) return;

                const maxSizeMB = CONSTANTS.MAX_IMAGE_SIZE_MB;
                const maxDimensions = CONSTANTS.MAX_IMAGE_DIMENSIONS;

                if (file.size > maxSizeMB * 1024 * 1024) {
                    setAppError(`圖片檔案過大，請上傳小於 ${maxSizeMB}MB 的檔案。`);
                    return;
                }

                const img = new Image();
                img.src = URL.createObjectURL(file);
                try {
                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            if (img.width > maxDimensions.width || img.height > maxDimensions.height) {
                                setAppError(`圖片尺寸過大，請上傳小於 ${maxDimensions.width}x${maxDimensions.height} 像素的圖片。`);
                                URL.revokeObjectURL(img.src);
                                reject();
                            } else {
                                resolve();
                            }
                        };
                        img.onerror = () => {
                             setAppError(`無法讀取圖片檔案。請確認圖片格式正確。`);
                             URL.revokeObjectURL(img.src);
                             reject();
                        };
                    });
                } catch {
                    return; // Error already set, prevent further processing
                } finally {
                    URL.revokeObjectURL(img.src); // Clean up the object URL
                }

                setIsUploading(true);
                setAppError(null); // Clear previous errors
                
                try {
                    const base64Image = await toBase64(file);
                    // --- 關鍵修改點：將 file.type 也傳遞給 onImageSelected ---
                    onImageSelected(base64Image, file.type); 
                    // --------------------------------------------------
                } catch (err) {
                    console.error("圖片讀取時發生錯誤:", err);
                    setAppError("該圖片無法處理。請嘗試其他檔案。");
                } finally {
                    setIsUploading(false);
                }
            }, [onImageSelected, setAppError]);

            const handleImageUpload = useCallback((event) => handleImageFile(event.target.files[0]), [handleImageFile]);
            
            const handleDragOver = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation(); 
                e.currentTarget.classList.add('drag-over');
            }, []);

            const handleDragLeave = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                e.currentTarget.classList.remove('drag-over');
            }, []);

            const handleDrop = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
                e.currentTarget.classList.remove('drag-over');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    handleImageFile(file);
                } else {
                    setAppError("請拖曳圖片檔案 (JPG/PNG)。");
                }
            }, [handleImageFile, setAppError]);

            return (
                <div className="console-panel">
                    <h2 className="console-section-header">
                        <i className="fa-solid fa-image fa-icon-large text-accent-blue-main"></i>
                        上傳您的角色圖片
                    </h2>
                    <div className="console-sub-panel !bg-transparent !shadow-none !border-none !p-0">
                        <div 
                            className={`image-upload-area ${uploadedImage ? 'has-image' : ''} ${isUploading ? 'uploading-animation' : ''}`}
                            onClick={() => !uploadedImage && !isAnyAiProcessActive && fileInputRef.current && fileInputRef.current.click()}
                            onDragOver={handleDragOver}
                            onDragLeave={handleDragLeave}
                            onDrop={handleDrop}
                            aria-label="拖曳或點擊以上傳角色圖片"
                            role="button"
                        >
                            {isUploading ? (
                                <div className="flex flex-col items-center" aria-live="polite">
                                    <LoadingSpinner className="fa-icon-xl" />
                                    <p className="text-text-muted-light mt-4">讀取中...</p>
                                </div>
                            ) : uploadedImage ? (
                                <img src={uploadedImage} alt="已上傳的角色圖片預覽" className="w-full h-full" />
                            ) : (
                                <div className="upload-placeholder flex flex-col items-center p-6 text-center">
                                    <i className="fa-solid fa-cloud-arrow-up fa-xxl icon text-accent-blue-main"></i>
                                    <p className="mt-2 text-lg text-dark-primary">點擊或拖曳檔案以上傳 (支援 JPG/PNG)</p>
                                    <p className="text-sm text-text-muted-light mt-2">請上傳清晰、細節豐富的角色圖片，以達到最佳公仔生成效果。</p>
                                    
                                </div>
                            )}
                        </div>
                        {uploadedImage && !isUploading && (
                            <div className="upload-buttons">
                                <Button onClick={() => fileInputRef.current && fileInputRef.current.click()} className="button-secondary" disabled={isAnyAiProcessActive} ariaLabel="更換已上傳的角色圖片">
                                    <i className="fa-solid fa-cloud-arrow-up fa-icon-medium"></i>
                                    更換圖片
                                </Button>
                            </div>
                        )}
                        <input type="file" ref={fileInputRef} onChange={handleImageUpload} accept="image/png, image/jpeg" className="hidden" aria-label="上傳圖片檔案" />
                    </div>
                </div>
            );
        };

        /**
         * Displays generated images, loading progress, and actions like download/retry/start over.
         * @param {Object} props - Component props.
         * @param {Array<Object>} props.generatedImages - Array of generated image objects.
         * @param {boolean} props.isLoading - Whether images are currently being generated.
         * @param {number} props.progress - Generation progress percentage.
         * @param {Function} props.onDownloadImage - Handler for downloading a single image.
         * @param {Function} props.onRegenerateImage - Handler to regenerate a single image.
         * @param {Function} props.onDownloadAll - Handler to download all successful images as a zip.
         * @param {Function} props.onStartOver - Handler to reset the application.
         * @param {boolean} props.isAnyAiProcessActive - Flag to disable actions during AI processes.
         */
        const ResultsDisplay = ({ 
            generatedImages, 
            isLoading, 
            progress, 
            onDownloadImage, 
            onRegenerateImage, 
            onDownloadAll, 
            onStartOver, 
            isAnyAiProcessActive 
        }) => {
            const resultsRef = useRef(null);

            useEffect(() => {
                if (isLoading) {
                    resultsRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, [isLoading]);

            const handleDownloadSingleImage = useCallback(() => {
                const successfulImage = generatedImages.find(img => img.status === 'success');
                if (successfulImage) {
                    onDownloadImage(successfulImage.imageUrl, successfulImage.id);
                } else {
                    alert("沒有可以下載的模型公仔圖片。");
                }
            }, [generatedImages, onDownloadImage]);


            if (!isLoading && generatedImages.length === 0) return null;

            return (
                <div ref={resultsRef} className="results-section">
                    <h2 className="console-section-header">
                        <i className="fa-solid fa-puzzle-piece fa-icon-large text-accent-blue-main"></i>
                        您的專屬模型公仔
                    </h2>

                    {isLoading && (
                        <div className="w-full max-w-lg mx-auto mb-10 text-center">
                            <div className="results-loader-progress">
                                <div
                                    className="results-loader-bar transition-all duration-500 ease-out"
                                    style={{ width: `${progress}%` }}
                                    role="progressbar"
                                    aria-valuenow={progress}
                                    aria-valuemin="0"
                                    aria-valuemax="100"
                                />
                            </div>
                            <p className="text-text-muted-light mt-4 text-sm">生成模型公仔時請保持視窗開啟</p>
                        </div>
                    )}
                    <div className="results-grid">
                        {generatedImages.map((img, index) => {
                            switch (img.status) {
                                case 'success':
                                    return <FigureDisplayCard
                                        key={`${img.id}-${index}-success`}
                                        sceneName={img.id}
                                        imageUrl={img.imageUrl}
                                        onDownload={onDownloadImage}
                                        onRegenerate={() => onRegenerateImage(index)}
                                        status={img.status}
                                    />;
                                case 'failed':
                                    return <ErrorFigureCard
                                        key={`${img.id}-${index}-failed`}
                                        sceneName={img.id}
                                        onRegenerate={() => onRegenerateImage(index)}
                                        status={img.status}
                                    />;
                                case 'pending':
                                case 'generating':
                                default:
                                    return <LoadingFigureCard 
                                        key={`${img.id}-${index}-pending`} 
                                        sceneName={img.id} 
                                        status={img.status}
                                    />;
                            }
                        })}
                    </div>

                    {!isLoading && generatedImages.length > 0 && (
                        <div className="text-center mt-20 flex flex-col sm:flex-row items-center justify-center gap-6">
                            <Button onClick={onStartOver} disabled={isAnyAiProcessActive} ariaLabel="重新開始新的生成">
                                <i className="fa-solid fa-arrow-rotate-right fa-icon-medium"></i>
                                重新開始
                            </Button>
                            {/* Only show download if all (1) are successful, and use single download logic */}
                            {generatedImages.length > 0 && generatedImages.every(img => img.status === 'success') && ( 
                                <Button onClick={handleDownloadSingleImage} primary disabled={isAnyAiProcessActive} ariaLabel="下載已成功生成的模型公仔圖片">
                                    <div className="flex items-center gap-2">
                                        <i className="fa-solid fa-download fa-icon-standard"></i>
                                        <span>下載圖片</span>
                                    </div>
                                </Button>
                            )}
                        </div>
                    )}
                </div>
            );
        };


        // --- Main Application Component ---
        const App = () => {
            const [uploadedImage, setUploadedImage] = useState(null); 
            const [uploadedImageMimeType, setUploadedImageMimeType] = useState(null); 
            const [generatedImages, setGeneratedImages] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            
            const [apiKey, setApiKey] = useState('');
            const [cooldownEndTime, setCooldownEndTime] = useState(0); 

            // New state for the logo image (UPDATED)
            const [logoImageDetails, setLogoImageDetails] = useState({
                base64: null,
                mimeType: null,
                isLoading: true, // Renamed from 'loaded', now truly reflects loading state
                error: false,    // Tracks if loading failed
            });

            // On component mount: load saved API key and the logo image
            useEffect(() => {
                const savedApiKey = localStorage.getItem('geminiApiKey');
                if (savedApiKey) {
                    setApiKey(savedApiKey);
                }

                // Function to fetch and convert the logo image to Base64 (UPDATED)
                const loadLogoImage = async () => {
                    try {
                        const response = await fetch(CONSTANTS.LOGO_IMAGE_PATH);
                        if (!response.ok) {
                            throw new Error(`Failed to load logo image: ${response.statusText} (${response.status})`);
                        }
                        const blob = await response.blob();
                        const base64 = await blobToBase64(blob);
                        setLogoImageDetails({
                            base64,
                            mimeType: blob.type,
                            isLoading: false, // Loading finished
                            error: false,
                        });
                        console.log('Logo image loaded successfully.');
                    } catch (err) {
                        console.error('Error loading logo image:', err);
                        // Set isLoading to false and error to true upon failure
                        setLogoImageDetails(prev => ({ ...prev, error: true, isLoading: false })); 
                        setAppError(setError, `無法載入品牌 LOGO 圖片。生成圖片時可能無法顯示 LOGO。詳細錯誤請查看控制台。`, `無法載入品牌 LOGO 圖片 (${CONSTANTS.LOGO_IMAGE_PATH}): ${err.message}`);
                    }
                };

                loadLogoImage();
            }, []); 

            // Cooldown timer effect
            useEffect(() => {
                const timer = setInterval(() => {
                    if (cooldownEndTime > 0 && Date.now() >= cooldownEndTime) {
                        setCooldownEndTime(0);
                        setError(null); // Clear 429 error message after cooldown
                    }
                }, 1000); 
                return () => clearInterval(timer);
            }, [cooldownEndTime]);


            // Handle API key input changes (Debounced and Sanitized)
            const handleApiKeyChange = useCallback(
                debounce((newKey) => {
                    const sanitizedKey = sanitizeApiKey(newKey);
                    setApiKey(sanitizedKey);
                    localStorage.setItem('geminiApiKey', sanitizedKey);
                }, CONSTANTS.DEBOUNCE_DELAY),
                []
            );

            const getActiveApiKey = useCallback(() => apiKey.trim(), [apiKey]);

            const setAppErrorMemo = useCallback((message, consoleMessage) => setAppError(setError, message, consoleMessage), []);
            const dismissError = useCallback(() => setError(null), []);

            const handleImageSelected = useCallback((base64Image, mimeType) => {
                setUploadedImage(base64Image);
                setUploadedImageMimeType(mimeType);
                setGeneratedImages([]); 
                setError(null);
                setCooldownEndTime(0); 
            }, []);


            // Prepare a list of image generation tasks based on the base prompt
            const figureGenerationTasks = useMemo(() => {
                const tasks = [];
                for (let i = 0; i < CONSTANTS.FIXED_GENERATE_COUNT; i++) {
                    const id = `現代電腦桌公仔`; 
                    const cleanId = `modern-computer-desk-figure`;
                    tasks.push({ id, cleanId, prompt: FIGURE_BASE_PROMPT });
                }
                return tasks;
            }, []);

            const regenerateImageAtIndex = useCallback(async (imageIndex) => {
                const imageToRegenerate = generatedImages[imageIndex];
                if (!imageToRegenerate || !uploadedImage || !uploadedImageMimeType) return;
            
                setGeneratedImages(prev => prev.map((img, index) =>
                    index === imageIndex ? { ...img, status: 'pending', imageUrl: null } : img
                ));
                setError(null);
            
                const currentApiKey = getActiveApiKey();
                if (!currentApiKey) {
                    setAppError(setError, "請提供您的 Google Gemini API 金鑰來重新生成模型公仔。");
                    setGeneratedImages(prev => prev.map((img, index) => index === imageIndex ? { ...img, status: 'failed' } : img));
                    return;
                }
    
                try {
                    const imageWithoutPrefix = uploadedImage.split(',')[1];
                    const modelInstruction = getModelInstruction(imageToRegenerate.prompt); 
                    
                    // Construct the parts array for Gemini API
                    const parts = [
                        CONSTANTS.SYSTEM_INSTRUCTION.parts[0],
                        { text: modelInstruction },
                        { inlineData: { mimeType: uploadedImageMimeType, data: imageWithoutPrefix } }
                    ];

                    // Add logo image ONLY IF it loaded successfully
                    if (!logoImageDetails.isLoading && !logoImageDetails.error && logoImageDetails.base64) {
                        parts.push({
                            inlineData: { mimeType: logoImageDetails.mimeType, data: logoImageDetails.base64.split(',')[1] }
                        });
                    } else if (logoImageDetails.error) {
                        console.warn("Skipping logo image in payload due to previous loading error.");
                    } else if (logoImageDetails.isLoading) {
                        console.warn("Skipping logo image in payload as it is still loading.");
                    }

                    const payload = {
                        contents: [{ parts }],
                        generationConfig: CONSTANTS.GENERATION_CONFIG,
                    };

                    const imageUrl = await generateImageWithRetry(payload, getActiveApiKey);

                    setGeneratedImages(prev => prev.map((img, index) =>
                        index === imageIndex ? { ...img, status: 'success', imageUrl } : img
                    ));
    
                } catch (err) {
                    // Specific handling for 429
                    if (err.message.includes('429') || err.message.includes('配額')) {
                        setCooldownEndTime(Date.now() + CONSTANTS.RATE_LIMIT_COOLDOWN_SECONDS * 1000);
                        setAppError(setError, `請求頻率過高，或配額已用盡。請等待 ${CONSTANTS.RATE_LIMIT_COOLDOWN_SECONDS} 秒後再試，或檢查您的 Google AI Studio 配額。`, `為 "${imageToRegenerate.id}" 重新生成失敗: ${err.message}`);
                    } else {
                        setAppError(setError, `哎呀！為 "${imageToRegenerate.id}" 重新生成失敗。錯誤: ${err.message}`);
                    }
                    setGeneratedImages(prev => prev.map((img, index) =>
                        index === imageIndex ? { ...img, status: 'failed' } : img
                    ));
                }
            }, [generatedImages, uploadedImage, uploadedImageMimeType, getActiveApiKey, setError, figureGenerationTasks, logoImageDetails, setCooldownEndTime]); 
            
            // Generate all images logic
            const handleGenerateClick = useCallback(async () => {
                if (cooldownEndTime > Date.now()) {
                    setAppError(setError, `請稍候。生成按鈕正在冷卻中，還有約 ${Math.ceil((cooldownEndTime - Date.now()) / 1000)} 秒。`);
                    return;
                }

                if (!uploadedImage || !uploadedImageMimeType) {
                    setAppError(setError, "請先上傳一張角色圖片！");
                    return;
                }
                
                const currentApiKey = getActiveApiKey();
                if (!currentApiKey) {
                    setAppError(setError, "請提供您的 Google Gemini API 金鑰來生成模型公仔。");
                    return;
                }
                
                // IMPORTANT: Check logo status before starting generation
                if (logoImageDetails.isLoading) {
                    setAppError(setError, "品牌 LOGO 圖片仍在載入中，請稍候。");
                    return;
                }
                if (logoImageDetails.error) {
                    setAppError(setError, "品牌 LOGO 圖片載入失敗，將無法包含 LOGO。請檢查瀏覽器控制台或嘗試重新整理。");
                    // Optionally, you could return here if logo is strictly required.
                    // For now, we'll proceed but log a warning and not include logo.
                }

                setIsLoading(true);
                setError(null);
                setGeneratedImages([]);
                setCooldownEndTime(0); 
                
                const imageWithoutPrefix = uploadedImage.split(',')[1];
                const initialPlaceholders = figureGenerationTasks.map(task => ({
                    id: task.id,
                    cleanId: task.cleanId, 
                    prompt: task.prompt, 
                    status: 'pending', 
                    imageUrl: null,
                }));
                setGeneratedImages(initialPlaceholders);

                // Generate images sequentially to manage state updates per pose
                for (let i = 0; i < figureGenerationTasks.length; i++) {
                    const task = figureGenerationTasks[i];
                    setGeneratedImages(prev => prev.map((img, index) => 
                        index === i ? { ...img, status: 'generating' } : img 
                    ));

                    try {
                        const modelInstruction = getModelInstruction(task.prompt);
                        
                        // Construct the parts array for Gemini API
                        const parts = [
                            CONSTANTS.SYSTEM_INSTRUCTION.parts[0],
                            { text: modelInstruction },
                            { inlineData: { mimeType: uploadedImageMimeType, data: imageWithoutPrefix } }
                        ];

                        // Add logo image ONLY IF it loaded successfully
                        if (!logoImageDetails.isLoading && !logoImageDetails.error && logoImageDetails.base64) {
                            parts.push({
                                inlineData: { mimeType: logoImageDetails.mimeType, data: logoImageDetails.base64.split(',')[1] }
                            });
                        } else if (logoImageDetails.error) {
                            console.warn("Skipping logo image in payload due to previous loading error.");
                        } else if (logoImageDetails.isLoading) {
                            console.warn("Skipping logo image in payload as it is still loading (should not happen here if checks are correct).");
                        }

                        const payload = {
                            contents: [{ parts }],
                            generationConfig: CONSTANTS.GENERATION_CONFIG,
                        };

                        const imageUrl = await generateImageWithRetry(payload, getActiveApiKey);

                        setGeneratedImages(prev => prev.map((img, index) => 
                            index === i ? { ...img, status: 'success', imageUrl } : img
                        ));

                    } catch (err) {
                        console.error(`為 ${task.id} 生成圖片在所有重試後失敗:`, err);
                        // Specific handling for 429
                        if (err.message.includes('429') || err.message.includes('配額')) {
                            setCooldownEndTime(Date.now() + CONSTANTS.RATE_LIMIT_COOLDOWN_SECONDS * 1000);
                            setAppError(setError, `請求頻率過高，或配額已用盡。請等待 ${CONSTANTS.RATE_LIMIT_COOLDOWN_SECONDS} 秒後再試，或檢查您的 Google AI Studio 配額。`, `為 "${task.id}" 生成失敗: ${err.message}`);
                        } else {
                            setAppError(setError, `哎呀！為 "${task.id}" 生成失敗。錯誤: ${err.message}`);
                        }
                        // Break out of the loop if a critical error like 429 or quota is hit
                        break; 
                    }
                    await new Promise(resolve => setTimeout(resolve, CONSTANTS.GENERATION_DELAY)); 
                }

                setIsLoading(false);
            }, [uploadedImage, uploadedImageMimeType, getActiveApiKey, figureGenerationTasks, setError, logoImageDetails, cooldownEndTime]);

            const triggerDownload = useCallback((href, fileName) => {
                const link = document.createElement('a');
                link.href = href;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }, []);
            
            const handleDownloadRequest = useCallback((imageUrl, sceneName) => {
                // Find the cleanId from the generatedImages state
                const generatedImage = generatedImages.find(img => img.id === sceneName);
                const fileName = generatedImage ? `figure-${generatedImage.cleanId}.png` : `figure-${Date.now()}.png`;
                triggerDownload(imageUrl, fileName);
            }, [triggerDownload, generatedImages]);

            const handleStartOver = useCallback(() => {
                setGeneratedImages([]);
                setUploadedImage(null);
                setUploadedImageMimeType(null);
                setError(null);
                setCooldownEndTime(0); 
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }, []);

            // Check if any AI-related process is active to disable general buttons
            const isAnyAiProcessActive = isLoading || cooldownEndTime > Date.now();

            const progress = useMemo(() => {
                const completed = generatedImages.filter(img => img.status === 'success' || img.status === 'failed').length;
                return generatedImages.length > 0 ? (completed / generatedImages.length) * 100 : 0;
            }, [generatedImages]);

            const getGenerateButtonText = () => {
                if (isLoading) {
                    return `生成中... (${Math.round(progress)}%)`;
                }
                if (cooldownEndTime > Date.now()) {
                    const remainingSeconds = Math.ceil((cooldownEndTime - Date.now()) / 1000);
                    return `請稍候 (${remainingSeconds} 秒)`;
                }
                return `模型公仔神生成`;
            };


            return (
                <>
                    <ErrorNotification message={error} onDismiss={dismissError} />
                    
                    <div className="container min-h-screen flex flex-col">
                        <header>
                            <h1 className="font-bold">
                                桌上模型公仔神生成系統
                            </h1>
                            <p>成為亮眼桌上模型公仔，不再只是夢想！</p>
                        </header>

                        <main className="flex-grow">
                            <div className="initial-setup-grid">
                                <ApiKeyInputSection 
                                    apiKey={apiKey} 
                                    onApiKeyChange={handleApiKeyChange} 
                                    isAnyAiProcessActive={isAnyAiProcessActive} 
                                />
                                <ImageUploadSection
                                    uploadedImage={uploadedImage}
                                    onImageSelected={(base64, mimeType) => handleImageSelected(base64, mimeType)}
                                    setAppError={setAppErrorMemo}
                                    isAnyAiProcessActive={isAnyAiProcessActive}
                                />
                            </div>

                            <div className="generate-button-area">
                                <Button
                                    onClick={handleGenerateClick}
                                    disabled={
                                        !uploadedImage || 
                                        !uploadedImageMimeType || 
                                        isAnyAiProcessActive || 
                                        !getActiveApiKey() || 
                                        logoImageDetails.isLoading || // Disable if logo is still loading
                                        (logoImageDetails.error && !logoImageDetails.base64) // Disable if logo failed to load AND no base64 (meaning it's essential)
                                    } 
                                    primary
                                    ariaLabel="生成模型公仔"
                                >
                                    <div className="flex items-center justify-center gap-3">
                                        {isLoading || cooldownEndTime > Date.now() ? (
                                            <>
                                                {isLoading && <LoadingSpinner className="fa-icon-standard" />}
                                                <span>{getGenerateButtonText()}</span>
                                            </>
                                        ) : (
                                            <>
                                                <i className="fa-solid fa-magic fa-icon-standard"></i>
                                                <span>{getGenerateButtonText()}</span>
                                            </>
                                        )}
                                    </div>
                                </Button>
                            </div>

                            <ResultsDisplay
                                generatedImages={generatedImages}
                                isLoading={isLoading}
                                progress={progress}
                                onDownloadImage={handleDownloadRequest}
                                onRegenerateImage={regenerateImageAtIndex}
                                onDownloadAll={handleDownloadRequest} 
                                onStartOver={handleStartOver}
                                isAnyAiProcessActive={isAnyAiProcessActive}
                            />
                        </main>
                        
                        <footer className="mt-auto"> 
                            <p>Copyright © Liyuchiutiger Gongminshen</p>
                        </footer>
                    </div>
                </>
            );
        };

        // Render the App component into the root div
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);

    </script>
</body>
</html>
--- END OF FILE index.html ---